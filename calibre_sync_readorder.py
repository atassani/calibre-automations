"""
calibre_sync_readorder.py

This script synchronizes the "readorder" tags in a Calibre library database with the
corresponding custom field "readorder" for each book and ensures consistency between
the tags and the custom field.

Key Features:
1. Removes duplicate "readorder" tags, keeping only the first one.
2. Adds a "readorder" tag if the custom field has a value but no tag exists.
3. Updates the "readorder" tag to match the custom field value if they differ.
4. Deletes the "readorder" custom field entry if its value is `0.0`.
5. Deletes the "readorder" tag if the custom field is empty (field takes precedence).

The script modifies the following tables in the Calibre database:
- `books_tags_link`: Links books to their associated tags.
- `tags`: Stores all available tags.
- `custom_column_<id>`: Stores the custom field data for "readorder".

Requirements:
- A valid Calibre SQLite database file.
- The "readorder" custom field must exist in the Calibre library.

Usage:
- Place the script in the same directory as your Calibre metadata database (`metadata.db`).
- Run the script using Python: `python calibre_sync_readorder.py`.

Author: Toni Tassani
Creation Date: 23 Nov 2024
Note: This code was generated by ChatGPT.
"""

import sqlite3

# Path to the Calibre database
db_path = "/Users/toni.tassani/CalibreLibrary/metadata.db"

def synchronize_readorder_tags(db_path):
    """
    Synchronize the "readorder" tags with the custom field "readorder" in a Calibre library,
    delete the "readorder" custom field entry if its value is 0.0, and delete the "readorder"
    tag if the custom field is empty.
    """
    # Connect to the Calibre database
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()

    # Identify the internal column table name for the custom 'readorder' field
    cursor.execute("SELECT label, id FROM custom_columns WHERE label = 'readorder'")
    readorder_column = cursor.fetchone()
    
    if not readorder_column:
        print("Custom field 'readorder' not found in the Calibre database.")
        conn.close()
        return
    
    readorder_table_name = f"custom_column_{readorder_column[1]}"  # e.g., "custom_column_3"

    # Query to fetch books, their tags, and custom readorder values
    query = f"""
        SELECT 
            b.id,
            b.title,
            (SELECT GROUP_CONCAT(t.name, ', ') 
             FROM books_tags_link bt 
             JOIN tags t ON bt.tag = t.id 
             WHERE bt.book = b.id) AS tags,
            (SELECT value FROM {readorder_table_name} WHERE book = b.id) AS custom_readorder
        FROM books b
        GROUP BY b.id;
    """
    try:
        cursor.execute(query)
    except sqlite3.OperationalError as e:
        print(f"Error executing query: {e}")
        conn.close()
        return

    # Process each book and make necessary modifications
    for row in cursor.fetchall():
        book_id, title, tags, custom_readorder = row
        tags = tags or ""
        tags_list = [tag.strip() for tag in tags.split(",") if tag.strip()]
        
        # Extract all readorder tags
        readorder_tags = [tag for tag in tags_list if tag.startswith("readorder:")]
        original_tags = tags_list.copy()  # Store the original tags for comparison

        # Case 1: More than one readorder tag
        if len(readorder_tags) > 1:
            # Keep only the first readorder tag
            readorder_tags = readorder_tags[:1]
            tags_list = [tag for tag in tags_list if not tag.startswith("readorder:")]
            tags_list = readorder_tags + tags_list  # Reinsert the first readorder tag
        
        # Case 2: No readorder tag but custom field exists
        if not readorder_tags and custom_readorder is not None:
            try:
                custom_readorder_value = float(custom_readorder)
                tags_list.append(f"readorder:{custom_readorder_value}")
            except ValueError:
                pass  # Ignore malformed custom field values

        # Case 3: Mismatch between tag and custom field
        elif readorder_tags and custom_readorder is not None:
            try:
                custom_readorder_value = float(custom_readorder)
                tag_value = float(readorder_tags[0].split(":")[1])
                if tag_value != custom_readorder_value:
                    # Update the tag to match the custom field value
                    tags_list = [tag for tag in tags_list if not tag.startswith("readorder:")]
                    tags_list.append(f"readorder:{custom_readorder_value}")
            except ValueError:
                pass  # Ignore malformed tag or custom field values

        # Case 4: Delete custom field if value is 0.0
        if custom_readorder is not None:
            try:
                custom_readorder_value = float(custom_readorder)
                if custom_readorder_value == 0.0:
                    delete_custom_field_query = f"DELETE FROM {readorder_table_name} WHERE book = ?;"
                    cursor.execute(delete_custom_field_query, (book_id,))
                    print(f"Deleted custom field 'readorder' for book '{title}' (value was 0.0).")
                    continue  # Skip further processing for this book
            except ValueError:
                pass  # Ignore malformed custom field values

        # Case 5: Delete readorder tag if custom field is empty
        if custom_readorder is None and readorder_tags:
            tags_list = [tag for tag in tags_list if not tag.startswith("readorder:")]
            print(f"Deleted 'readorder' tag for book '{title}' (no custom field value).")

        # Skip the update if there are no changes to the tags
        if tags_list == original_tags:
            #print(f"No changes needed for book '{title}'.")
            continue

        # Update the tags in the `tags` table
        # First, delete all existing tags for the book
        delete_tags_query = "DELETE FROM books_tags_link WHERE book = ?;"
        cursor.execute(delete_tags_query, (book_id,))

        # Reinsert updated tags
        for tag in tags_list:
            # Check if the tag already exists in the `tags` table
            cursor.execute("SELECT id FROM tags WHERE name = ?", (tag,))
            tag_row = cursor.fetchone()
            if not tag_row:
                # Insert new tag into the `tags` table
                cursor.execute("INSERT INTO tags (name) VALUES (?);", (tag,))
                tag_id = cursor.lastrowid
            else:
                tag_id = tag_row[0]

            # Link the tag to the book
            cursor.execute("INSERT INTO books_tags_link (book, tag) VALUES (?, ?);", (book_id, tag_id))

        print(f"Updated tags for book '{title}': {', '.join(tags_list)}")

    # Commit the changes
    conn.commit()
    print("Synchronization complete.")
    conn.close()

# Run the synchronization function
if __name__ == "__main__":
    synchronize_readorder_tags(db_path)

